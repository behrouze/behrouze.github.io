{
    "componentChunkName": "component---src-templates-wp-post-tsx",
    "path": "/graphql",
    "result": {"pageContext":{"id":"418ce2e4-9362-53c7-b2b4-77480ad5fc21","fileAbsolutePath":"/Users/behrouze/Sources/gatsby-blog/obsidian/Blog/graphql.md","frontmatter":{"categories":["javascript"],"date":"2018-10-31","lastUpdate":null,"tags":["javascript","react"],"title":"GraphQL"},"html":"<h1>GraphQL</h1>\n<p><a href=\"http://www.graphql.org/\">GraphQL</a> est une nouvelle norme d'API, qui fourni une <strong>alternative plus efficace, puissance et flexible à REST</strong> développé à l'<a href=\"https://youtu.be/9sc8Pyc51uU?t=31\">origine par Facebook</a>, pour répondre à un besoin de transfert de données adaptés aux nouveaux usages du web (mobile avec des taux de transfert restreint et qualité de connexion pas toujours au top).</p>\n<p>Pour schématiser, GraphQL est composé d'un <strong>client</strong> et d'un <strong>serveur</strong> (l'API). C'est une sorte de <strong>concentrateur</strong> qui va jouer le rôle de <strong>point d'entrée unique des requêtes clientes</strong> qui va faire le <strong>lien</strong> avec toutes les <strong>différentes sources de données</strong> coté Back (API REST, bases de données, fichiers etc).</p>\n<h2>Caractéristiques principales</h2>\n<ol>\n<li>les clients <strong>récupèrent les données</strong> de manières <strong>déclarative</strong>, en spécifiant ce dont ils ont précisément besoin</li>\n<li>1 <strong>unique point d'entrée</strong>, 1 seule URL (contrairement aux API REST)</li>\n<li>possibilité pour les équipes Front End (aussi en charge du serveur GraphQL) de modifier rapidement les UI (et donc leurs besoins en données)</li>\n<li>lorsque plusieurs clients ont besoin d'accéder aux mêmes sources de données, avec chacun des besoins particuliers en API, l'architecture REST oblige la modification des endpoints directement, alors qu'avec GraphQL <strong>le serveur GraphQL va filtrer et renvoyer juste les données nécessaire</strong> (possibilité de mettre en cache en amont) en mixant et filtrant les données issues de différents endpoints</li>\n<li><strong>Monitoring</strong> et infos <strong>Analytics</strong> possible (dans les resolvers)</li>\n<li><strong>typage fort</strong></li>\n</ol>\n<p><strong>Apollo</strong> est un ensemble d'outils et de bibliothèques, créés selon les specs GraphQL, permettant de mettre en place rapidement un serveur GraphQL.</p>\n<h2>Concepts</h2>\n<p><strong>Schema</strong> : <strong>contrat</strong> (ou interface) <strong>entre</strong> le <strong>client</strong> et le <strong>serveur GraphQL</strong>, c'est la description de l'ensemble des <strong>types simples</strong> ainsi que des <strong>fonctionnalités</strong> (types d'opérations/requêtes) disponibles sur le serveur graphQL. Il est défini à travers une chaine de caractère passé en paramètre de la méthode buildSchema( ) écrite en langage SDL .</p>\n<p><strong>SDL</strong> : Schema Definition Language, est un langage de description des types disponibles dans un schéma et les relations entre ces types. Ce langage spécifique à GraphQL doit etre stocké sous forme de String (plus simple avec les [[javascript-es6|templates litterals]])</p>\n<p>Les <strong><a href=\"https://www.apollographql.com/docs/resources/graphql-glossary.html#operation\">opérations</a></strong> disponibles sont de 3 <a href=\"https://blog.apollographql.com/the-anatomy-of-a-graphql-query-6dffa9e9e747\">types</a> :</p>\n<ul>\n<li><strong>query</strong> : lecture de données</li>\n<li><strong>mutation</strong> : création, modification ou suppression de données</li>\n<li><strong>subscription</strong> : souscription à des éventements temps réel</li>\n</ul>\n<p><strong>Resolvers</strong> : fonctions permettant d'interagir avec les données</p>\n<h2>Schema et Operations</h2>\n<p><strong>Coté serveur GraphQL</strong>, un <strong>schema</strong> est formé d'une collection de <strong>types objet</strong>, ainsi que des types un peu particuliers, les <strong>root types:</strong></p>\n<blockquote>\n<p>schema = types racine (query, mutations) + types objet</p>\n</blockquote>\n<h3>Types simple ou primitifs (<a href=\"https://graphql.org/graphql-js/type/#scalars\">scalar types</a>)</h3>\n<ul>\n<li><strong>Int</strong>: entier 32‐bit signé</li>\n<li><strong>Float</strong>: float à double-precision</li>\n<li><strong>String</strong>: séquence de caractères UTF‐8</li>\n<li><strong>Boolean</strong>: true ou false</li>\n<li><strong>ID</strong> (serialisé en tant que String)</li>\n</ul>\n<h3>Types objet ou concrets (<a href=\"https://www.apollographql.com/docs/apollo-server/essentials/schema.html#object\">object types</a>)</h3>\n<p>Les types objets ou <strong>types concrets</strong> vont définir la <strong>structure des données</strong> et sont composés de <strong>pairs de clés/types</strong> <strong>primitifs</strong> ou  <strong>clés/types</strong> <strong>objet</strong>. Ici le <strong>type</strong> <em>Person</em> est constitué des <strong>champs</strong> name, age et posts :</p>\n<p>type Person {\nname: String!\nage: Int!\nposts: [Post!]!\n}</p>\n<p>L'ensemble des types objets d'un schéma constitue le <strong>Modèle</strong>.</p>\n<h3>Types racine (root level types)</h3>\n<p><strong>3 types spéciaux</strong> existent par convention, ce sont les types <a href=\"https://graphql.org/learn/schema/#the-query-and-mutation-types\"><strong>Query</strong>, <strong>Mutations</strong></a> et <strong>Subscription</strong>. Ce sont eux qui vont définir les <strong>points d'entrées de notre API</strong>, ils vont permettre aux clients GraphQL d'interagir avec le serveur GraphQL. Nous pouvons en utiliser un ou plusieurs dans notre schéma :</p>\n<p>type Query { ... }\ntype Mutation { ... }\ntype Subscription { ... }</p>\n<p>Chacun de ces 3 <strong>root types</strong> va définir les <strong>root field</strong> de l'API, qui sont les points d'entrées des requêtes clientes</p>\n<p>type Query {\nallPersons(last: Int): [Person!]!\n}</p>\n<h3>Modificateurs de types : lists et non null</h3>\n<p>Les <strong>champs obligatoires</strong> sont marqué avec le <strong>\"!\"</strong></p>\n<p>Les <strong>tableaux</strong> sont comme en Javascript représentés par des <strong>[ ]</strong></p>\n<h3>Enumérations (<a href=\"https://graphql.org/learn/schema/#enumeration-types\">Enumeration types</a>)</h3>\n<p>Permet comme les enums de C# de définir un type qui est restreint à un ensemble défini de valeurs:</p>\n<p>enum Message {\nMAIL\nSMS\nPHONE\n}</p>\n<h3>Types interfaces</h3>\n<p>Une <strong><a href=\"https://www.apollographql.com/docs/guides/schema-design.html#interfaces\">interface</a></strong> est un <strong>contrat ou abstraction</strong> qui peut être implémenté par un type, on la définie avec le mot clé <a href=\"https://graphql.org/learn/schema/#interfaces\"><strong>interface</strong></a> :</p>\n<p>interface Message {\nid: ID!\ntitre: String!\nmessage: String!\ndestinataires: [Contacts]!\n}</p>\n<p>et nos types peuvent l'implémenter en spécifiant le mot clé <strong>implements</strong> devant le nom de notre type Objet :</p>\n<p>type Email implements Message {\nid: ID!\ntitre : String!\nmessage: String!\ndestinataires: [Contacts]!\ncc: [Contacts]\ncci: [Contacts]\n}</p>\n<h2>Opération <strong>coté</strong> client</h2>\n<p>Une <strong>opération</strong> exécutée <strong>coté client</strong> de <strong>type query</strong> pourrait ressembler à :</p>\n<p>query {\nallPersons(last: 2) {\nname\n}\n}</p>\n<p>On va ici interroger le serveur GraphQL, pour exécuter la Query allPersons en passant le paramètre optionnel last, pour récupérer les champs names uniquement.</p>\n<h2>Liens</h2>\n<p><a href=\"https://www.howtographql.com/\">HowToGraphQL.com</a> Tuto vidéos gratuits de référence <a href=\"https://www.howtographql.com/\">Fullstack GraphQL</a> et <a href=\"https://graphql.org/blog/\">blog</a> (avec <a href=\"https://graphql.org/blog/rest-api-graphql-wrapper/\">exemples d'implémentations</a>)</p>\n<p>Features <a href=\"https://blog.apollographql.com/announcing-apollo-server-2-2b69fb4702ce\">d'Apollo V2</a> (19/07/18) et <a href=\"https://www.apollographql.com/docs/apollo-server/v2/getting-started.html\">tuto officiel Apollo 2</a> et leur nombreux articles sur <a href=\"https://blog.apollographql.com\">leur blog</a> :</p>\n<ol>\n<li><a href=\"https://blog.apollographql.com/graphql-explained-5844742f195e\">GraphQL explained</a></li>\n<li><a href=\"https://blog.apollographql.com/tutorial-building-a-graphql-server-cddaa023c035\">How to build a GraphQL server</a></li>\n<li>Apollo Client: <a href=\"https://blog.apollographql.com/apollo-client-graphql-with-react-and-redux-49b35d0f2641\">GraphQL with React and Redux</a></li>\n<li><a href=\"https://blog.apollographql.com/whats-next-js-for-apollo-e4dfe835d070\">What’s Next.js for Apollo</a></li>\n</ol>\n<p>Repo Github <a href=\"https://github.com/apollographql/apollo-server#readme\">Apollo server 2 pour Express</a></p>\n<p>Conferences dediés à GraphQL <a href=\"https://summit.graphql.com/\">GraphQL Summit</a> ou <a href=\"https://graphql-europe.org/\">GraphQL Europe</a></p>\n<p><a href=\"https://graphqlradio.com/\">GraphQL Radio</a> podcast et la newsletter <a href=\"https://graphqlweekly.com/\">GraphQL Weekly</a></p>\n<p>Prisma (ORM) GraphQL Server Basics | <a href=\"https://blog.graph.cool/graphql-server-basics-the-schema-ac5e2950214e\">Part I: GraphQL Schemas, TypeDefs &#x26; Resolvers Explained</a> | <a href=\"https://blog.graph.cool/graphql-server-basics-the-network-layer-51d97d21861\">Part II: The Network Layer</a> | <a href=\"https://blog.graph.cool/graphql-server-basics-demystifying-the-info-argument-in-graphql-resolvers-6f26249f613a\">Part III: Demystifying the <code class=\"language-text\">info</code> argument in GraphQL resolvers</a></p>\n<p><a href=\"https://codesandbox.io/s/nn9y2wzyw4\">React/Apollo client</a> implémentation (dans un CodeSandbox)</p>"}},
    "staticQueryHashes": ["1026020893","28434099","3153813225"]}