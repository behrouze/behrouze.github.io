{
    "componentChunkName": "component---src-templates-wp-post-tsx",
    "path": "/docker",
    "result": {"pageContext":{"id":"e762c3bb-24ee-56f3-9a78-866b51fdc98e","fileAbsolutePath":"/Users/behrouze/Sources/gatsby-blog/obsidian/Blog/docker.md","frontmatter":{"categories":["devops"],"date":"2017-11-10","lastUpdate":null,"tags":["devops","docker","linux","raspberry-pi","intro"],"title":"Docker introduction pour débutants"},"html":"<p><a href=\"https://www.docker.comhttp://\"><img src=\"logo_docker_large.png\" alt=\"Docker virtualisation grâce à des images et containers\"></a></p>\n<p>En tant que développeur, il nous arrive de vouloir \"essayer\" telle ou telle librairie, faire un petit POC rapide pour choisir une base de donnée parmi plusieurs. Il était possible d'<strong>isoler</strong> des environnement de travail et de les rendre \"temporaires\" ou \"jetable\" grâce à des solutions de virtualisations (plus ou moins lourde ou onéreuses) depuis de nombreuses années. Docker est apparue comme une alternative \"légère\" à la Virtualisation classique en machines virtuelles car elle se repose sur le système d'exploitation hôte (contrairement aux VM qui nécessite une install d'OS) pour ceux qui développent en environnement Linux.</p>\n<p><em>Attention</em>: on lit souvent que docker permet de déployer \"cross plateform\", mais il faut noter que les <strong>images</strong> sont <strong>dépendantes</strong> de l'<strong>OS</strong> et de l'<strong>architecture CPU hôte</strong>. Il faudra donc utiliser une méthode nommé <strong><a href=\"https://docs.docker.com/develop/develop-images/multistage-build/\">multistage build</a></strong> si votre environnement de dév est sous Linux sur un PC (x64) et que vous souhaitez déployer sur des Raspberry Pi (armV7). Voir également <a href=\"https://docs.docker.com/machine/overview/#whats-the-difference-between-docker-engine-and-docker-machine\">Docker Machine</a> (anciennement <a href=\"http://boot2docker.io/\">Boot2docker</a>)</p>\n<h2>Concepts de base</h2>\n<p><a href=\"https://docs.docker.com/get-started/#docker-concepts\">Docker</a> nous permet de <strong>créer un environnement isolé</strong> capable de faire tourner des services (comme des serveur web, smtp ou autres) ou de lancer des exécutables, <strong>sans interférer avec le système hôte</strong>.</p>\n<h3>Mots clé</h3>\n<h4>Image</h4>\n<p>Une <strong>image docker</strong> c'est un <strong>package exécutable en lecture seule</strong>, qui comprend tout ce qui est nécessaire pour lancer une application (le code, runtime, bibliothèques, var d'environnement et fichiers de conf). Une image Docker peut être une application web complète, un serveur quelconque ou juste un exécutable. Il existe de nombreuses images facilement récupérables depuis un <a href=\"https://hub.docker.com/explore/\">repo Docker</a>, elles <strong>nous serviront de base</strong> pour <strong>construire notre propre image</strong> (contenant notre toute dernière SPA par ex).</p>\n<h4>Container</h4>\n<p>Un <strong>docker container</strong> c'est l'<strong>instance d'une image</strong>, c'est une image qui est \"exécutée\" et visible avec la commande docker ps</p>\n<h4>DockerFile</h4>\n<p><a href=\"https://docs.docker.com/get-started/part2/#define-a-container-with-dockerfile\">le DockerFile</a> est <em>un fichier de commandes</em> qui va nous <strong>permet de créer une image personnalisée</strong> en se basant sur des images existantes puis la configuration et installation d'outils divers</p>\n<h4>Docker Engine</h4>\n<p>Le <strong>docker engine</strong> est le moteur de Docker <strong>coté serveur</strong>, il se compose du process (deamon) <code class=\"language-text\">dockerd</code>, qui va permettre de gérer les <strong>containers</strong> et <strong>images</strong>.\nPour interagir avec ce docker engine nous disposons d'une <a href=\"https://docs.docker.com/engine/api/sdk/\">API REST ainsi que d'un SDK</a>.</p>\n<p>Le <strong>SDK officiel</strong> supporte <em>Python</em> et <em>Go</em> mais il existe également de nombreuses <a href=\"https://docs.docker.com/engine/api/sdk/#unofficial-libraries\">bibliothèques non officiels</a> pour différents languages de programmations :</p>\n<ul>\n<li>C# : <a href=\"https://github.com/dotnet/Docker.DotNet\">Docker.DotNet </a></li>\n<li>Nodejs : <a href=\"https://github.com/apocas/dockerode\">dockernode</a></li>\n</ul>\n<p>L'API REST se nomme le Docker Engine API, et comme toute API bien concue, elle est versionnée. Sélection la version de l'API selon les versions de Docker daemon et Docker client utilisés.</p>\n<h4>Docker Hub</h4>\n<p>Repository d'images dockers pour <a href=\"https://github.com/docker-library/official-images#architectures-other-than-amd64\">divers architectures matériels</a> (et spécificquement pour <a href=\"https://hub.docker.com/u/arm32v7\">ici Raspberry Pi</a>)</p>\n<h2>Commandes de base</h2>\n<p><code class=\"language-text\">docker images</code>  : liste l'ensemble des <strong>images</strong> présente en local (machine faisant tourner le deamon docker)</p>\n<p><code class=\"language-text\">docker ps -a</code>  ou <code class=\"language-text\">docker container ls -all</code>  : liste l'ensemble des <strong>containers</strong> (même ceux qui sont exited)</p>\n<p><code class=\"language-text\">docker diff e319dc35e14e</code>  : affiche la <strong>différence</strong> entre le <strong>container</strong> (l'argument est le CONTAINER ID fournie par docker ps ) et l'<strong>image</strong> à partir de laquelle il a été lancé</p>\n<p><code class=\"language-text\">docker commit e319dc35e14e debian-perso</code> : <strong>enregistre</strong> le <strong>container</strong> ayant l'<strong>ID</strong> spécifié dans une image nommée <em>debian-perso</em></p>\n<p><code class=\"language-text\">docker save debian-perso > ~/debian-perso.tar</code>  : <strong>exporte l'image</strong> <em>debian-perso</em> sur dans le home de l'utilisateur courant sous forme de fichier tar</p>\n<p><code class=\"language-text\">docker run --hostname=dockerized --name=toto -ti debian</code>  : <strong>lance</strong> l'image <em>debian</em> en nommant le container \"toto\" et en spécifiant le nom d’hôte dokerized, en mode interactif</p>\n<p><code class=\"language-text\">docker run --hostname=dockerized -v /tmp/local:/tmp/container -ti debian</code> : <strong>lance</strong> l'image debian en <strong>mappant un dossier</strong> de la machine hôte sur un dossier du container, cela permet de faire persister les fichiers</p>\n<h3>Gestion par lots</h3>\n<p>docker ps -aq  : <strong>liste</strong> des <strong>ID de tous les containers</strong> présent en local (l'option quiet filtre toutes les autres infos)</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">docker</span> stop <span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">docker</span> <span class=\"token function\">ps</span> -aq<span class=\"token variable\">`</span></span>  <span class=\"token comment\"># arrête tous le containers</span>\n<span class=\"token function\">docker</span> <span class=\"token function\">rm</span> <span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">docker</span> <span class=\"token function\">ps</span> -aq<span class=\"token variable\">`</span></span>    <span class=\"token comment\"># supprime tous le containers</span>\n<span class=\"token function\">docker</span> rmi <span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">docker</span> <span class=\"token function\">ps</span> -aq<span class=\"token variable\">`</span></span>   <span class=\"token comment\"># supprime toutes les images</span></code></pre></div>\n<h2>Tips</h2>\n<h3>Installation</h3>\n<p>Il existe différentes méthodes d'installation en fonction de l'OS hote:</p>\n<ul>\n<li>Debian x64 utiliser <a href=\"https://docs.docker.com/install/linux/docker-ce/debian/#set-up-the-repository\">apt</a></li>\n<li>Raspberry pi utiliser cette méthode qui va <a href=\"https://docs.docker.com/install/linux/docker-ce/debian/#install-using-the-convenience-script\">exploiter le script get-docker.sh</a></li>\n<li>pour les <a href=\"http://mwhiteley.com/linux-containers/2013/08/31/docker-on-i386.html\">vieux PC (i386) sous Linux voici la démarche</a> (récupérer et compiler les sources) ou utiliser <a href=\"https://github.com/docker-32bit/ubuntu/blob/master/build-image.sh\">ce script</a> (pour Ubuntu i386)</li>\n</ul>\n<p>mais la plus simple est d'exécuter le <a href=\"https://docs.docker.com/install/linux/docker-ce/debian/#install-using-the-convenience-script\">script d'installation</a>:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">curl</span> -fsSL https://get.docker.com -o get-docker.sh</code></pre></div>\n<h3>Post-installation</h3>\n<p>Si vous souhaitez utiliser docker sans sudo à chaque commande, il suffit d'ajouter les logins au group docker (a créer s'il n'existe pas):</p>\n<ol>\n<li>Créer le groupe <code class=\"language-text\">docker</code>.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">sudo</span> <span class=\"token function\">groupadd</span> <span class=\"token function\">docker</span></code></pre></div>\n<ol start=\"2\">\n<li>Ajouter l’utilisateur courant (ou un autre a spécifier) au groupe système <code class=\"language-text\">docker</code>.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">sudo</span> <span class=\"token function\">usermod</span> -aG <span class=\"token function\">docker</span> <span class=\"token environment constant\">$USER</span></code></pre></div>\n<h3>Tester l'installation locale de docker</h3>\n<p>Pour vérifier son installation, faire un simple docker -v  puis  tenter de lancer une image (ici <a href=\"https://hub.docker.com/r/arm32v7/nginx\">Nginx pour Raspberry Pi</a>) en prenant soin de mettre un fichier index.html dans le dossier spécifié en paramètre :</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">docker</span> run --name testwebsrv -v /dossier/local/contenant/du/html:/usr/share/nginx/html:ro -d -p <span class=\"token number\">8080</span>:80 arm32v7/nginx</code></pre></div>\n<p>❗ si on obtient une erreur standard_init_linux.go:207: exec user process caused \"exec format error\"  c'est que l'image que l'on souhaite exécuter n'est pas adaptée à l'architecture CPU locale (ex on essaye de lancer une image X64 sur un ARMv7).</p>\n<h3>Désintallation</h3>\n<p>Si l'installation a été faite via le script Curl fourni par le site Docke sur une distribution type Debian (ex raspbian), la <strong>désinstallation</strong> se fait avec <strong>dpkg</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">sudo</span> dpkg -l<span class=\"token operator\">|</span><span class=\"token function\">grep</span> <span class=\"token function\">docker</span> <span class=\"token comment\"># pour vérifier que le(s) package docker est bien présent</span>\n<span class=\"token function\">sudo</span> dpkg --remove --force-remove-reinstreq docker-ce\n<span class=\"token function\">sudo</span> <span class=\"token function\">groupdel</span> <span class=\"token function\">docker</span></code></pre></div>\n<h3>Liens</h3>\n<p><a href=\"http://docker-saigon.github.io/post/Docker-Internals\">Concepts avancés</a></p>"}},
    "staticQueryHashes": ["1026020893","1333896537","28434099"]}