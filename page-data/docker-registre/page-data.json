{
    "componentChunkName": "component---src-templates-wp-post-tsx",
    "path": "/docker-registre",
    "result": {"pageContext":{"id":"68b98b0a-eee8-593f-a019-61d9ffd5fc3c","fileAbsolutePath":"/home/behrouze/Sources/gatsby-blog/obsidian/Blog/docker-registre.md","frontmatter":{"categories":["devops"],"date":"2019-12-13","lastUpdate":null,"tags":["docker","linux","raspberry-pi"],"title":"Registre Docker privé"},"html":"<p>Docker permet d’utiliser <a href=\"https://docs.docker.com/registry/deploying/#run-a-local-registry\">auto-héberger des registres Docker</a> sur notre propre infrastructure.</p>\n<p>On peut vouloir héberger un registre Docker sur ses serveurs pour divers raisons comme pour par exemple <em>« maîtriser » l’accès à ses images docker</em>, les <em>rendre disponible sur le réseau local</em> (qui peut être isolé d’internet), pour des raisons de <em>performances</em> (notamment avec une CI locale) ou juste pour <em>comprendre</em> ? comment fonctionne l’écosystème Docker.</p>\n<p>Ce poste est basé de la <a href=\"https://docs.docker.com/registry/insecure/#use-self-signed-certificates\">certificats auto-générés/signés</a>.</p>\n<h2>Vue d’ensemble</h2>\n<p><img src=\"images/Docker-Registry-1.png\" alt=\"registre docker local\"></p>\n<h2>Installation</h2>\n<h3>Coté serveur</h3>\n<p>Le registre docker que nous allons utiliser est simplement une instance d’une image officielle <code class=\"language-text\">registry:2</code>, il va donc falloir avoir un environnement docker fonctionnel installé sur le serveur et une pair <a href=\"https://www.digitalocean.com/community/tutorials/openssl-essentials-working-with-ssl-certificates-private-keys-and-csrs\">clé SSL/certificat</a> car la connexion au registre docker doit être sécurisée (requis par défaut).</p>\n<h4>Génération de la clé et certificat par OpenSsl</h4>\n<p>D’abord se placer dans le dossier dans lequel nous allons stocker la clé privée et le certificat signé (dossier <code class=\"language-text\">certs</code>), puis les générer:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">openssl req -newkey rsa:4096 -nodes -sha256      <span class=\"token punctuation\">\\</span>\n     -keyout docker-registry.key -x509 -days <span class=\"token number\">365</span> <span class=\"token punctuation\">\\</span>\n     -out docker-registry.crt</code></pre></div>\n<h4>Configuration [optionnel]</h4>\n<p>Il est possible de configurer finement le Registre via un fichier <a href=\"https://docs.docker.com/registry/configuration/#list-of-configuration-options\">config.yml</a> monté dans un volume, mais c’est <em>optionnel</em> (sauf si vous visez une configuration de production):</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">docker</span> run -d -p <span class=\"token number\">443</span>:443 --restart<span class=\"token operator\">=</span>always --name registry   <span class=\"token punctuation\">\\</span>\n      -v <span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token builtin class-name\">pwd</span><span class=\"token variable\">`</span></span>/config.yml:/etc/docker/registry/config.yml <span class=\"token punctuation\">\\</span>\n      registry:2</code></pre></div>\n<h4>Démarrer le registre local</h4>\n<p>Démarrer le conteneur docker basé sur l’image officielle <code class=\"language-text\">registry:2</code> :</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">docker</span> run -d --restart<span class=\"token operator\">=</span>always --name mon-registre -v <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">pwd</span><span class=\"token variable\">)</span></span>\"</span>/certs:/certs -e <span class=\"token assign-left variable\">REGISTRY_HTTP_ADDR</span><span class=\"token operator\">=</span><span class=\"token number\">0.0</span>.0.0:443 -e <span class=\"token assign-left variable\">REGISTRY_HTTP_TLS_CERTIFICATE</span><span class=\"token operator\">=</span>/certs/docker-registry.crt -e <span class=\"token assign-left variable\">REGISTRY_HTTP_TLS_KEY</span><span class=\"token operator\">=</span>/certs/docker-registry.key -p <span class=\"token number\">443</span>:443 registry:2\n<span class=\"token comment\"># se placer dans le dossier contenant le dossier certs</span></code></pre></div>\n<h3>Coté client</h3>\n<h4>Copie du certificat serveur sur les clients Docker</h4>\n<p>Il faut uniquement installer le certificat (fichier <code class=\"language-text\">docker-registry.crt</code>) que nous avons précédemment généré coté serveur dans un dossier spécifique <code class=\"language-text\">/etc/docker/certs.d/mon-serveur:443/docker-registry.crt</code> de chaque client docker qui souhaite communiquer avec.</p>\n<h4>Envoi réception des images</h4>\n<p>Utiliser les commandes docker push/pull avec la <a href=\"https://docs.docker.com/engine/security/trust/content_trust/\">syntaxe suivante</a> <code class=\"language-text\">[REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</code> pour envoyer/recevoir vers son registre privé exemple :</p>\n<p>docker pull mon-serveur:443/mon-image</p>\n<h2>Troubleshooting des erreurs docker</h2>\n<p>Si vous tentez de récupérer une image sur votre Registre Docker fraichement installé, vous risquez de rencontrer quelques erreurs dont certains liés aux certificats.</p>\n<h3>Vérifier la liaison réseau</h3>\n<p>Il peut être utile de vérifier depuis le client que le conteneur docker est bien lancé coté serveur et qu’il écoute bien sur le port spécifié (443 dans notre exemple):</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">nc</span> -vz  mon-serveur <span class=\"token number\">443</span>\n\n<span class=\"token comment\"># le résultat devrait ressembler à cela:</span>\n<span class=\"token comment\"># Connection to mon-serveur 443 port [tcp/https] succeeded!</span></code></pre></div>\n<h3>Server gave HTTP response to HTTPS client</h3>\n<p>Error response from daemon: Get <a href=\"https://mon-serveur:443/v2/\">https://mon-serveur:443/v2/</a>: http: server gave HTTP response to HTTPS client</p>\n<h4>Explication</h4>\n<p>Le serveur (le registre docker) a été lancé sans certificat spécifiés par les variables d’environnements <code class=\"language-text\">REGISTRY_HTTP_TLS_CERTIFICATE</code> et/ou <code class=\"language-text\">REGISTRY_HTTP_TLS_KEY</code></p>\n<h4>Solution</h4>\n<p>Vérifier que vous avez bien les fichiers <code class=\"language-text\">.cert</code> et <code class=\"language-text\">.key</code> (avec le bon chemin lors du lancement de la commande docker run) et que vous avez bien renseigné les options <code class=\"language-text\">-e</code> comme spécifié ci-dessus (installation coté serveur).</p>\n<h3>Unknown authority: certificat manquant coté client</h3>\n<p>Error response from daemon: Get <a href=\"https://mon-serveur:443/v2/\">https://mon-serveur:443/v2/</a>: x509: certificate signed by unknown authority</p>\n<h4>Explication</h4>\n<p>Ce message indique <em>certificate signed by unknown authority</em>, c’est à dire que votre client ne reconnait pas l’autorité qui a signé le certificat SSL recu de votre serveur.</p>\n<h4>Solution</h4>\n<p>copier votre certificat <code class=\"language-text\">docker-registry.crt</code> sur votre client dans le dossier <code class=\"language-text\">/etc/docker/certs.d/mon-serveur:443/docker-registry.crt</code></p>\n<h3>x509: certificate is not valid</h3>\n<p>Error response from daemon: Get <a href=\"https://mon-serveur:443/v2/\">https://mon-serveur:443/v2/</a>: x509: certificate is not valid for any names, but wanted to match mon-serveur</p>\n<h4>Explication</h4>\n<p>Ce message indique <em>certificate is not valid … but wanted to match mon-serveur</em>, c’est à dire que la <strong>connexion a bien été établie</strong> avec le registre docker privé, mais que le <strong>certificat renvoyé ne correspond pas nom de domaine</strong> (ici mon-serveur).</p>\n<h4>Solution</h4>\n<p>Régénérer le certificat et la clé coté serveur en renseignant correctement la question :</p>\n<p>Common Name (e.g. server FQDN or YOUR name) []:mon-serveur</p>"}},
    "staticQueryHashes": ["1026020893","1333896537","28434099"]}